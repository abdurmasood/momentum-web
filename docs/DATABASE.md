# Database

## Overview

Momentum uses **Neon PostgreSQL** (serverless PostgreSQL) with **Prisma ORM** for database management. The database stores user accounts, OAuth provider data, sessions, and verification tokens required for NextAuth v5 authentication.

## Database Provider

### Neon PostgreSQL

**Type**: Serverless PostgreSQL (fully managed)

**Features**:
- **Autoscaling**: Scales to zero when inactive
- **Connection Pooling**: Built-in pooling for serverless environments
- **Branching**: Database branches for testing/staging
- **Point-in-Time Recovery**: Backup and restore capabilities
- **SSL Connections**: Encrypted connections by default

**Dashboard**: [https://console.neon.tech](https://console.neon.tech)

### Connection Strings

Neon provides two connection strings:

**1. Pooled Connection** (`DATABASE_URL`):
```bash
DATABASE_URL="postgresql://user:password@host-pooler.region.aws.neon.tech/dbname?sslmode=require"
```
- **Use for**: Application queries (Prisma Client)
- **Features**: Connection pooling, optimized for serverless
- **Concurrent connections**: Up to 1000 (pooled)

**2. Direct Connection** (`DIRECT_URL`):
```bash
DIRECT_URL="postgresql://user:password@host.region.aws.neon.tech/dbname?sslmode=require"
```
- **Use for**: Prisma migrations, schema pushes
- **Features**: Direct connection, no pooling
- **Concurrent connections**: Limited (10-20)

**When to Use Which**:
- Runtime queries → `DATABASE_URL` (pooled)
- Migrations/schema changes → `DIRECT_URL` (direct)

[REVIEW: Confirm connection limits for your Neon plan]

## Prisma ORM

### Configuration

**Schema Location**: [prisma/schema.prisma](../prisma/schema.prisma)

**Generator**:
```prisma
generator client {
  provider = "prisma-client-js"
}
```

**Datasource**:
```prisma
datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}
```

### Prisma Client

**Singleton Instance**: [src/lib/prisma.ts](../src/lib/prisma.ts)

**Implementation**:
```typescript
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as { prisma?: PrismaClient }

export const prisma = globalForPrisma.prisma ?? new PrismaClient()

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma
}
```

**Why Singleton**:
- Prevents multiple Prisma Client instances
- Avoids connection pool exhaustion
- Required for Next.js development (hot reload)

**Usage**:
```typescript
import { prisma } from '@/lib/prisma'

const users = await prisma.user.findMany()
```

## Database Schema

### NextAuth v5 Models

All models follow the [NextAuth Prisma Adapter schema](https://authjs.dev/getting-started/adapters/prisma).

### User Model

**Table**: `users`

```prisma
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}
```

**Fields**:
- `id` - Unique identifier (CUID format, not auto-increment)
- `name` - User's display name (nullable, may be null for magic link users)
- `email` - User's email address (unique, required)
- `emailVerified` - Timestamp when email was verified (null for OAuth)
- `image` - Profile image URL (from OAuth provider)
- `createdAt` - Account creation timestamp
- `updatedAt` - Last update timestamp

**Relationships**:
- `accounts` - One-to-many with Account (OAuth providers)
- `sessions` - One-to-many with Session (active sessions)

**Indexes**:
- Primary key: `id`
- Unique: `email`

**CUID Format**:
- Example: `ckl0r5q2z0000z2z5g5y5z5z5`
- Benefits: URL-safe, sortable, no collisions
- Generated by Prisma automatically

### Account Model

**Table**: `accounts`

```prisma
model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
  @@map("accounts")
}
```

**Fields**:
- `userId` - Foreign key to User
- `type` - Account type (e.g., "oauth", "email")
- `provider` - Provider name (e.g., "google", "email")
- `providerAccountId` - User ID from provider (e.g., Google user ID)
- `refresh_token` - OAuth refresh token (nullable)
- `access_token` - OAuth access token (nullable)
- `expires_at` - Token expiration timestamp (nullable)
- `token_type` - Token type (e.g., "Bearer")
- `scope` - OAuth scopes granted
- `id_token` - OpenID Connect ID token (nullable)
- `session_state` - OAuth session state (nullable)

**Relationships**:
- `user` - Many-to-one with User (cascade delete)

**Composite Primary Key**:
- `[provider, providerAccountId]` - Unique per provider

**Example Data** (Google OAuth):
```javascript
{
  userId: "ckl0r5q2z0000z2z5g5y5z5z5",
  type: "oauth",
  provider: "google",
  providerAccountId: "1234567890",
  access_token: "ya29.a0AfH6...",
  token_type: "Bearer",
  scope: "openid profile email",
  id_token: "eyJhbGciOiJSUzI1NiIs...",
  expires_at: 1640000000
}
```

### Session Model

**Table**: `sessions`

```prisma
model Session {
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("sessions")
}
```

**Fields**:
- `sessionToken` - Unique session identifier
- `userId` - Foreign key to User
- `expires` - Session expiration timestamp
- `createdAt` - Session creation timestamp
- `updatedAt` - Last update timestamp

**Relationships**:
- `user` - Many-to-one with User (cascade delete)

**Indexes**:
- Unique: `sessionToken`

**Note**: This model is used for **database sessions** strategy. Momentum uses **JWT sessions** strategy, so this table may remain empty in production.

[REVIEW: Confirm if database sessions are used anywhere]

### VerificationToken Model

**Table**: `verification_tokens`

```prisma
model VerificationToken {
  identifier String
  token      String
  expires    DateTime

  @@id([identifier, token])
  @@map("verification_tokens")
}
```

**Fields**:
- `identifier` - Email address (for magic link auth)
- `token` - Unique verification token (hashed)
- `expires` - Token expiration timestamp

**Composite Primary Key**:
- `[identifier, token]` - Unique per email/token combination

**Usage**:
- Stores magic link tokens
- Token expires in 10 minutes (configured in NextAuth)
- Single-use tokens (deleted after verification)

**Example Data**:
```javascript
{
  identifier: "user@example.com",
  token: "abc123def456...",  // Hashed token
  expires: "2025-01-15T10:15:00.000Z"
}
```

**Automatic Cleanup**:
- Expired tokens should be cleaned up periodically
- [REVIEW: Is there a cron job for cleanup? Document in API.md if so]

## Database Operations

### Common Queries

**Find User by Email**:
```typescript
const user = await prisma.user.findUnique({
  where: { email: 'user@example.com' }
})
```

**Find User with Accounts**:
```typescript
const user = await prisma.user.findUnique({
  where: { email: 'user@example.com' },
  include: {
    accounts: true,
    sessions: true
  }
})
```

**Create User**:
```typescript
const user = await prisma.user.create({
  data: {
    email: 'user@example.com',
    name: 'User Name',
    emailVerified: new Date()
  }
})
```

**Update User**:
```typescript
const user = await prisma.user.update({
  where: { id: 'user-id' },
  data: { name: 'New Name' }
})
```

**Delete User** (cascades to accounts/sessions):
```typescript
await prisma.user.delete({
  where: { id: 'user-id' }
})
```

**List All Users** (with pagination):
```typescript
const users = await prisma.user.findMany({
  take: 10,
  skip: 0,
  orderBy: { createdAt: 'desc' }
})
```

**Count Users**:
```typescript
const count = await prisma.user.count()
```

### Transactions

**Example** (create user with account):
```typescript
const result = await prisma.$transaction(async (tx) => {
  const user = await tx.user.create({
    data: { email: 'user@example.com' }
  })

  const account = await tx.account.create({
    data: {
      userId: user.id,
      type: 'oauth',
      provider: 'google',
      providerAccountId: '1234567890'
    }
  })

  return { user, account }
})
```

**When to Use Transactions**:
- Multiple related operations must succeed/fail together
- Data integrity critical
- Prevents partial updates

### Raw SQL Queries

**Simple Raw Query**:
```typescript
const users = await prisma.$queryRaw`
  SELECT * FROM users WHERE email LIKE ${pattern}
`
```

**Parameterized Query**:
```typescript
import { Prisma } from '@prisma/client'

const email = 'user@example.com'
const user = await prisma.$queryRaw(
  Prisma.sql`SELECT * FROM users WHERE email = ${email}`
)
```

**When to Use Raw SQL**:
- Complex queries not supported by Prisma
- Performance optimization
- Database-specific features

**Security Note**: Always use parameterized queries (prevents SQL injection)

## Schema Management

### Development Workflow

**1. Edit Schema**:
```prisma
// prisma/schema.prisma
model User {
  // Add new field
  phone String?
}
```

**2. Push to Database** (development only):
```bash
npm run db:push
```
- Updates database schema instantly
- No migration files created
- Good for prototyping

**3. Regenerate Prisma Client**:
```bash
npm run db:generate
```

**4. Restart Dev Server**

### Production Workflow (Migrations)

[REVIEW: Document migration workflow for production]

**1. Create Migration**:
```bash
npx prisma migrate dev --name add-phone-field
```

**2. Apply Migration** (production):
```bash
npx prisma migrate deploy
```

**Migration Files**: Stored in `prisma/migrations/`

**Best Practices**:
- Never edit migration files manually
- Always test migrations in staging first
- Backup production database before migrating
- Use `migrate deploy` in production (not `migrate dev`)

### Schema Validation

**Validate Schema**:
```bash
npx prisma validate
```

**Format Schema**:
```bash
npx prisma format
```

**Check Database Sync**:
```bash
npx prisma db pull
```
Generates schema from existing database (useful for debugging)

## Database Tools

### Prisma Studio

**Launch**:
```bash
npm run db:studio
```

**URL**: [http://localhost:5555](http://localhost:5555)

**Features**:
- Visual database browser
- Edit records directly
- Filter and search
- Relationship navigation
- Useful for development/debugging

**Security**: Only use in development (not production-safe)

### Neon Dashboard

**Features**:
- SQL editor (run queries directly)
- Database branching
- Monitoring and metrics
- Connection string management
- Backup/restore

**Access**: [https://console.neon.tech](https://console.neon.tech)

[REVIEW: Add screenshots or specific instructions for common Neon tasks]

## Performance Optimization

### Indexing

**Current Indexes**:
- `users.id` - Primary key (automatic)
- `users.email` - Unique index (automatic)
- `accounts.[provider, providerAccountId]` - Composite primary key
- `sessions.sessionToken` - Unique index
- `verification_tokens.[identifier, token]` - Composite primary key

**Adding Custom Index**:
```prisma
model User {
  // ...

  @@index([createdAt])  // Index for sorting by creation date
}
```

### Query Optimization

**Use Select** (fetch only needed fields):
```typescript
const users = await prisma.user.findMany({
  select: {
    id: true,
    email: true,
    name: true
    // Don't fetch unused fields
  }
})
```

**Pagination**:
```typescript
const users = await prisma.user.findMany({
  take: 10,     // Limit
  skip: 20,     // Offset
  cursor: { id: 'last-id' }  // Cursor-based (more efficient)
})
```

**Avoid N+1 Queries**:
```typescript
// Bad: N+1 query problem
const users = await prisma.user.findMany()
for (const user of users) {
  const accounts = await prisma.account.findMany({ where: { userId: user.id } })
}

// Good: Single query with include
const users = await prisma.user.findMany({
  include: { accounts: true }
})
```

### Connection Pooling

**Neon Built-in Pooling**:
- Use `DATABASE_URL` (pooled connection)
- Up to 1000 concurrent connections
- Optimized for serverless/edge functions

**Prisma Connection Limits**:
```typescript
// src/lib/prisma.ts
const prisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.DATABASE_URL
    }
  }
})
```

**Best Practices**:
- Use singleton pattern (prevents multiple clients)
- Close connections in API routes (not needed with serverless)
- Monitor connection usage in Neon dashboard

## Backup & Recovery

### Neon Backups

**Automatic Backups**:
- Neon automatically backs up databases
- Point-in-time recovery available
- Retention period: [REVIEW: Check your Neon plan retention]

**Manual Backup** (via SQL):
```bash
pg_dump $DATABASE_URL > backup.sql
```

**Restore from Backup**:
```bash
psql $DATABASE_URL < backup.sql
```

### Database Branching

**Create Branch**:
- Neon dashboard → Branches → Create Branch
- Branch inherits schema and data from parent
- Use for testing schema changes

**Workflow**:
1. Create branch from production
2. Test schema changes on branch
3. If successful, apply to production
4. Delete branch

[REVIEW: Document specific branching strategy for your team]

## Security

### Connection Security

- **SSL Required**: All connections use SSL (`sslmode=require`)
- **Credentials**: Never commit database URLs to git
- **Environment Variables**: Store URLs in `.env` (gitignored)

### Data Security

**Encryption**:
- At-rest: Neon encrypts all data automatically
- In-transit: SSL connections encrypt data
- Backups: Also encrypted

**Access Control**:
- Database credentials only in environment variables
- No public database access (Neon network isolation)
- Use database roles if needed [REVIEW: Are database roles configured?]

### SQL Injection Prevention

**Prisma Parameterization**:
```typescript
// Safe: Prisma automatically parameterizes
await prisma.user.findMany({
  where: { email: userInput }
})

// Also safe: Explicit parameterization
await prisma.$queryRaw(
  Prisma.sql`SELECT * FROM users WHERE email = ${userInput}`
)

// UNSAFE: String concatenation
await prisma.$queryRawUnsafe(
  `SELECT * FROM users WHERE email = '${userInput}'`  // Don't do this!
)
```

**Best Practices**:
- Always use Prisma query builder or `$queryRaw` with Prisma.sql
- Never use `$queryRawUnsafe` with user input
- Validate/sanitize user input before queries

## Monitoring

### Query Logging

**Enable in Development**:
```typescript
// src/lib/prisma.ts
const prisma = new PrismaClient({
  log: ['query', 'info', 'warn', 'error']
})
```

**Production Logging**:
```typescript
const prisma = new PrismaClient({
  log: ['error', 'warn']  // Only errors/warnings
})
```

### Performance Monitoring

**Neon Dashboard Metrics**:
- Query performance
- Connection count
- Database size
- CPU/memory usage

[REVIEW: Add specific monitoring tools/alerts configured]

### Error Handling

**Example**:
```typescript
try {
  const user = await prisma.user.create({ data: { email } })
} catch (error) {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    // Unique constraint violation
    if (error.code === 'P2002') {
      throw new Error('Email already exists')
    }
  }
  throw error
}
```

**Common Error Codes**:
- `P2002` - Unique constraint violation
- `P2025` - Record not found
- `P2003` - Foreign key constraint violation

## Troubleshooting

### Common Issues

**"Can't reach database server"**:
- Check `DATABASE_URL` is correct
- Verify Neon database is running (not paused)
- Check firewall/network settings

**"Prisma Client not generated"**:
```bash
npm run db:generate
```

**"Database is out of sync"**:
```bash
npm run db:push
```

**"Too many connections"**:
- Use pooled connection (`DATABASE_URL`)
- Check for connection leaks in code
- Monitor Neon dashboard for active connections

**Migration Conflicts**:
```bash
# Reset database (DANGER: deletes all data)
npx prisma migrate reset

# Or manually resolve in prisma/migrations/
```

[REVIEW: Add more troubleshooting based on production experience]

## Data Seeding

[REVIEW: Is database seeding implemented? If so, document:]

**Seed Script**: `prisma/seed.ts` (if exists)

**Run Seeding**:
```bash
npm run db:seed
```

**Example Seed Data**:
- Test users
- Sample accounts
- Development data

## Maintenance Tasks

### Regular Maintenance

**1. Clean Expired Tokens**:
[REVIEW: Document if automated, or add manual query]
```typescript
await prisma.verificationToken.deleteMany({
  where: {
    expires: { lt: new Date() }
  }
})
```

**2. Monitor Database Size**:
- Check Neon dashboard regularly
- Archive old sessions if needed
- Clean up test data

**3. Review Slow Queries**:
- Check Neon performance metrics
- Add indexes where needed
- Optimize queries

[REVIEW: Document any automated maintenance scripts/cron jobs]

---

*Last Updated: January 2025*
*Version: 1.0.0*
